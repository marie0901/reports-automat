"""AWOL Plugin - Inactive users campaigns report."""

import pandas as pd
from pathlib import Path
from typing import Dict, List
import logging
from openpyxl import Workbook, load_workbook
import copy

from ..base import BaseReportPlugin, register_plugin

logger = logging.getLogger(__name__)

AWOL_MAPPINGS = {"Day 1": "1d", "Day 3": "3d", "Day 5": "5d", "Day 10": "10d", "Day 15": "15d", "Day 20": "20d", "Day 30": "30d", "Day 40": "40d"}
WEEKLY_BOUNDARIES = [
    ("2025-12-29", "2026-01-04"),
    ("2026-01-05", "2026-01-11"),
    ("2026-01-12", "2026-01-18"),
    ("2026-01-19", "2026-01-25"),
    ("2026-01-26", "2026-02-01"),
    ("2026-02-02", "2026-02-08"),
]
METRICS = ["sent", "delivered", "opened", "clicked", "converted", "unsubscribed"]
WEEK_COLUMNS = {'week1': 'K', 'week2': 'J', 'week3': 'I', 'week4': 'H', 'week5': 'G', 'week6': 'F'}
TIMING_BLOCKS = {
    "1d": {"inactive7": [3, 8], "inactive14": [11, 16], "inactive22": [19, 24], "inactive31": [27, 32]},
    "10d": {"inactive7": [35, 40], "inactive14": [43, 48], "inactive22": [51, 56], "inactive31": [59, 64]},
}
WEEK_MAPPINGS = {
    'source': {'01': 'K', '02': 'J', '03': 'I', '04': 'H', '05': 'G', '06': 'F'},
    'target': {'01': 'BF', '02': 'BE', '03': 'BD', '04': 'BC', '05': 'BB', '06': 'BA'}
}

SHEET_MAPPINGS = {
    'awol': 'AWOL Chains Sport'
}


@register_plugin
class AWOLPlugin(BaseReportPlugin):
    """AWOL report plugin."""
    
    name = "awol"
    supports_multiple_files = True
    
    def __init__(self):
        self.existing_excel = None
        self.replace_week = None
    
    def process_csv(self, csv_paths: List[Path]) -> Dict[str, pd.DataFrame]:
        data_files = {}
        for path in csv_paths:
            df = pd.read_csv(path)
            df['datetime'] = pd.to_datetime(df['timestamp'], unit='s')
            data_files[path.name] = df
            logger.info(f"Loaded {path.name}: {len(df)} rows")
        return data_files
    
    def transform_data(self, data_files: Dict[str, pd.DataFrame]) -> Dict[str, Dict[str, pd.DataFrame]]:
        report_data = {}
        
        for file_name, data in data_files.items():
            filtered = data[data['template_name'].isin(AWOL_MAPPINGS.keys())]
            
            weekly_data = {}
            for i, (start_date, end_date) in enumerate(WEEKLY_BOUNDARIES, 1):
                start = pd.to_datetime(start_date + ' 00:00:00')
                end = pd.to_datetime(end_date + ' 23:59:59')
                week_mask = (filtered['datetime'] >= start) & (filtered['datetime'] <= end)
                week_df = filtered[week_mask].groupby('template_name')[METRICS].sum().reset_index()
                weekly_data[f'week{i}'] = week_df
            
            file_report = {}
            for template_name, timing_category in AWOL_MAPPINGS.items():
                timing_data = {}
                for week_key, week_df in weekly_data.items():
                    template_data = week_df[week_df['template_name'] == template_name]
                    if not template_data.empty:
                        template_data = self._calculate_percentages(template_data)
                        timing_data[week_key] = template_data
                    else:
                        timing_data[week_key] = self._empty_data(template_name)
                file_report[timing_category] = timing_data
            
            report_data[file_name] = file_report
        
        return report_data
    
    def _calculate_percentages(self, data: pd.DataFrame) -> pd.DataFrame:
        result = data.copy()
        result['pct_delivered'] = (result['delivered'] / result['sent'] * 100).fillna(0)
        result['pct_open'] = (result['opened'] / result['delivered'] * 100).fillna(0)
        result['pct_click'] = (result['clicked'] / result['delivered'] * 100).fillna(0)
        result['pct_cr'] = (result['converted'] / result['delivered'] * 100).fillna(0)
        return result
    
    def _empty_data(self, template_name: str) -> pd.DataFrame:
        return pd.DataFrame([{
            'template_name': template_name, 'sent': 0, 'delivered': 0, 'opened': 0,
            'clicked': 0, 'converted': 0, 'unsubscribed': 0,
            'pct_delivered': 0, 'pct_open': 0, 'pct_click': 0, 'pct_cr': 0
        }])
    
    def generate_excel(self, report_data: Dict[str, Dict[str, pd.DataFrame]], output_path: Path):
        wb = Workbook()
        ws = wb.active
        
        week_headers = {
            'week6': ("06", "02.02"), 'week5': ("05", "26.01"), 'week4': ("04", "19.01"),
            'week3': ("03", "12.01"), 'week2': ("02", "05.01"), 'week1': ("01", "29.12")
        }
        for week_key, col_letter in WEEK_COLUMNS.items():
            if week_key in week_headers:
                week_display, date = week_headers[week_key]
                ws[f'{col_letter}1'] = f"Week {week_display}\n{date}"
        
        logger.info(f"Processing {len(report_data)} files")
        for file_name, section_data in report_data.items():
            logger.info(f"File: {file_name}")
            if "inactive7" in file_name.lower():
                self._populate_section(ws, section_data, "inactive7", "Inactive 7 [SPORT] ⚽️")
            elif "inactive14" in file_name.lower():
                self._populate_section(ws, section_data, "inactive14", "Inactive 14 [SPORT] ⚽️")
            elif "inactive22" in file_name.lower():
                self._populate_section(ws, section_data, "inactive22", "Inactive 22 [SPORT] ⚽️")
            elif "inactive31" in file_name.lower():
                self._populate_section(ws, section_data, "inactive31", "Inactive 31+ [SPORT] ⚽️")
        
        wb.save(output_path)
        logger.info(f"Excel saved: {output_path}")
        
        if self.existing_excel and self.replace_week:
            self._replace_week(output_path, self.existing_excel, self.replace_week)
    
    def _populate_section(self, ws, section_data: Dict, section_key: str, campaign_name: str):
        current_row = 3 if section_key == "inactive7" else \
                     11 if section_key == "inactive14" else \
                     27 if section_key == "inactive22" else 43
        
        templates_with_data = []
        for timing_category in section_data.keys():
            has_data = any(not df.empty and df['sent'].iloc[0] > 0 
                          for df in section_data[timing_category].values() 
                          if not df.empty)
            if has_data:
                templates_with_data.append(timing_category)
        
        templates_with_data.sort(key=lambda x: int(x.replace('d', '')))
        
        for timing_category in templates_with_data:
            template_name = {v: k for k, v in AWOL_MAPPINGS.items()}.get(timing_category, timing_category)
            
            ws[f'B{current_row}'] = campaign_name.replace(" [SPORT] ⚽️", "").lower()
            ws[f'C{current_row}'] = " All Mail"
            ws[f'D{current_row}'] = template_name
            
            timing_data = section_data[timing_category]
            # 8 metrics: sent, delivered, opened, clicked, unsubscribed, %delivered, %open, %click
            metrics = ["sent", "delivered", "opened", "clicked", "unsubscribed", "pct_delivered", "pct_open", "pct_click"]
            
            for i, metric in enumerate(metrics):
                row = current_row + i
                
                for week_key, col_letter in WEEK_COLUMNS.items():
                    if week_key in timing_data and not timing_data[week_key].empty:
                        df = timing_data[week_key]
                        if metric in df.columns:
                            ws[f'{col_letter}{row}'] = df[metric].iloc[0]
                    else:
                        ws[f'{col_letter}{row}'] = 0
            
            current_row += 8
    
    def _replace_week(self, generated_path: Path, existing_path: Path, week_number: str):
        source_col = WEEK_MAPPINGS['source'][week_number]
        target_col = WEEK_MAPPINGS['target'][week_number]
        
        generated_wb = load_workbook(generated_path, data_only=False)
        existing_wb = load_workbook(existing_path, data_only=False)
        
        generated_ws = generated_wb.active
        
        # Get target sheet based on report type
        sheet_name = SHEET_MAPPINGS.get('awol', existing_wb.sheetnames[0])
        if sheet_name in existing_wb.sheetnames:
            existing_ws = existing_wb[sheet_name]
        else:
            existing_ws = existing_wb.active
            logger.warning(f"Sheet '{sheet_name}' not found, using active sheet")
        
        self._copy_formatting(existing_ws, 'BE', target_col)
        
        copied = 0
        
        source_blocks = {}
        for source_row in range(1, generated_ws.max_row + 1):
            source_b = generated_ws[f'B{source_row}'].value
            source_d = generated_ws[f'D{source_row}'].value
            if source_b and source_d:
                key = (str(source_b).strip().lower(), str(source_d).strip())
                source_blocks[key] = source_row
        
        for (campaign, template), source_start in source_blocks.items():
            target_start = self._find_target_block(existing_ws, campaign, template)
            if target_start:
                for offset in range(8):  # 8 metrics per block
                    source_row = source_start + offset
                    target_row = target_start + offset
                    
                    # Skip if target cell has a formula
                    target_cell = existing_ws[f'{target_col}{target_row}']
                    if isinstance(target_cell.value, str) and target_cell.value.startswith('='):
                        continue
                    
                    value = generated_ws[f'{source_col}{source_row}'].value
                    if value is not None:
                        existing_ws[f'{target_col}{target_row}'].value = value
                        copied += 1
        
        output_path = existing_path.parent / f"updated_{existing_path.name}"
        existing_wb.save(output_path)
        logger.info(f"Updated Excel saved: {output_path} ({copied} values)")
    
    def _copy_formatting(self, ws, source_col: str, target_col: str):
        for row in range(1, ws.max_row + 1):
            source_cell = ws[f'{source_col}{row}']
            target_cell = ws[f'{target_col}{row}']
            # Only copy style, not formulas
            if source_cell.has_style and not (isinstance(source_cell.value, str) and source_cell.value and source_cell.value.startswith('=')):
                target_cell.font = copy.copy(source_cell.font)
                target_cell.fill = copy.copy(source_cell.fill)
                target_cell.border = copy.copy(source_cell.border)
                target_cell.alignment = copy.copy(source_cell.alignment)
                target_cell.number_format = source_cell.number_format
    
    def _find_target_block(self, ws, campaign: str, template: str) -> int:
        # First find campaign start
        campaign_start = None
        for row in range(1, ws.max_row + 1):
            cell_b = ws[f'B{row}'].value
            if cell_b and campaign in str(cell_b).lower():
                campaign_start = row
                break
        
        if not campaign_start:
            return None
        
        # Then find template within campaign section (next 100 rows)
        for row in range(campaign_start, min(campaign_start + 100, ws.max_row + 1)):
            cell_d = ws[f'D{row}'].value
            if cell_d and template.lower() in str(cell_d).lower():
                return row
            # Stop if we hit next campaign
            cell_b = ws[f'B{row}'].value
            if cell_b and row > campaign_start and str(cell_b).strip():
                break
        
        return None
    
    def execute(self, input_paths: List[Path], output_path: Path, existing_excel: Path = None, replace_week: str = None):
        self.existing_excel = existing_excel
        self.replace_week = replace_week
        
        for path in input_paths:
            self.validate_input(path)
        
        data_files = self.process_csv(input_paths)
        report_data = self.transform_data(data_files)
        self.generate_excel(report_data, output_path)
